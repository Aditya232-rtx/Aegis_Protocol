# ğŸ›¡ï¸ Aegis Protocol

### AI-Driven Insolvency Protection & Liquidity Sponge

**Aegis Protocol** is a next-generation decentralized lending safety layer that prevents liquidation cascades using Artificial Intelligence and Cross-Chain ZK-Proofs. It acts as a "Liquidity Sponge," absorbing bad debt during market volatility rather than dumping collateral, protecting both the protocol and the user.

---

## ğŸš¨ The Problem
Traditional DeFi lending protocols (like Aave or Compound) rely on **Atomic Liquidations**:
1.  **Price Crashes**: Collateral value drops.
2.  **Instant Sell-Off**: Liquidators seize collateral and immediately sell it on DEXs to repay debt.
3.  **Cascading Slippage**: This selling pressure drives prices down further, triggering *more* liquidations.
4.  **Inefficiency**: Users lose 10-15% in penalties, and the market suffers from "MEV wars" and gas spikes.

## ğŸ’¡ The Solution: Aegis Sponge
Aegis introduces a **Probationary Liquidation** mechanism:
1.  **AI Sentinel**: Continuously monitors wallet risk using off-chain ML models.
2.  **Sponge Rescue**: When a user enters the "Red Zone" (Critical Risk), they are not immediately liquidated. Instead, the **Backstop Pool (Sponge)** interacts:
    *   It pays off the user's debt (USDC) to the pool.
    *   It takes custody of the collateral (ETH).
    *   **It Does NOT Sell**: The Sponge holds the collateral, waiting for market stabilization or executing gradual, optimized exits via Dark Pools (CoW Swap).
3.  **ZKML Verification**: All risk scoring and state transitions are verified on-chain, ensuring the AI cannot be manipulated.

---

## ğŸŒŸ Key Features (USPs)

### 1. ğŸ§¼ Liquidity Sponge (The "Backstop")
A dedicated liquidity pool funded by LPs that "soaks up" bad debt. It acts as the buyer of last resort, preventing toxic assets from hitting the open market and causing slippage.

### 2. ğŸ§  Decentralized ZKML (Zero-Knowledge Machine Learning)
We don't just trust a centralized bot. The AI model's inferences (Risk Scores) are cryptographically proved.
*   **Sentinel**: Python/JS agent generates a risk score.
*   **Verifier**: A smart contract guarantees that the score came from the specific, approved ML model without revealing the model weights.

### 3. ğŸŒ‰ Cross-Chain Security via Ergo (Rosen Bridge)
We leverage the **Ergo Blockchain** for decentralized logic enforcement.
*   **Guard Scripts (ErgoScript)**: The heavy lifting of ZK verification is decentralized.
*   **Rosen Bridge**: Transmits the verified "Risk State" (Green/Red) from Ergo to Ethereum (EVM) trustlessly.

---

## ğŸ—ï¸ Project Structure

```bash
Aegis_Protocol/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ blockchain-evm/       # Solidity Smart Contracts (The Core)
â”‚   â”‚   â”œâ”€â”€ contracts/
â”‚   â”‚   â”‚   â”œâ”€â”€ core/         # AegisPool, AegisCore, BackstopPool
â”‚   â”‚   â”‚   â””â”€â”€ security/     # Verifier, IdentityRegistry
â”‚   â”‚   â””â”€â”€ scripts/          # Chaos Monkey & Deployment
â”‚   â”‚
â”‚   â”œâ”€â”€ frontend-cockpit/     # Next.js Dashboard (The UI)
â”‚   â”‚   â”œâ”€â”€ app/components/   # Reusable UI Widgets (RiskGauge, AssetCard)
â”‚   â”‚   â””â”€â”€ hooks/            # Blockchain Integration Hooks
â”‚   â”‚
â”‚   â”œâ”€â”€ ml-sentinel/          # AI Risk Engine (Python/TensorFlow)
â”‚   â”‚   â””â”€â”€ models/           # Pre-trained Sentinel Models
â”‚   â”‚
â”‚   â””â”€â”€ blockchain-ergo/      # ErgoScript & Off-Chain Logic
â”‚       â””â”€â”€ src/              # Guard Scripts for Rosen Bridge
```

---

## ğŸ” Decentralizing ZKML with ErgoScript

A critical innovation of Aegis is how we handle **Model Integrity**. We don't want a centralized admin flipping a "Panic Switch."

### The Ergo Guard Script
We deploy a **Guard Script** on the Ergo blockchain that acts as an immutable logic gate for the Rosen Bridge watchers.

1.  **Commitment**: The ML Model's hash is hardcoded into the Guard Script (or a UTXO register).
2.  **Proof Submission**: The Sentinel submits a ZK-Proof (RiscZero/Halo2) asserted to the Guard Address.
3.  **Verification Logic**:
    *   The Guard Script checks `Verify(Proof, PublicInputs, ModelHash) == true`.
    *   It ensures the `RiskScore` output matches the input data.
    *   **Crucially**: The Guard Script *prevents* any transaction that updates the Global Risk State unless a valid ZK Proof is attached.
4.  **Bridging**: Once the Ergo transaction is confirmed (meaning the Proof is valid), the Rosen Bridge watchers observe the state change and relay the specific boolean flag (`isCritical: true`) to the Ethereum `AegisCore` contract.

This architecture ensures that **not even the developers** can trigger a system-wide liquidation event without a mathematical proof of insolvency generated by the governed AI model.

---

## ğŸš€ Getting Started

1.  **Install Dependencies**: `npm install` (root)
2.  **Spin Up Chain**: `cd packages/blockchain-evm && npx hardhat node`
3.  **Deploy**: `npx hardhat run scripts/deploy-and-export.js`
4.  **Simulate Risk**: `npx hardhat run scripts/chaos-monkey-live.js`
5.  **Run UI**: `cd packages/frontend-cockpit && npm run dev`
