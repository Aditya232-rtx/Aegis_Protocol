// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AegisRiscZeroVerifier
 * @notice Risc Zero ZK Verifier for LSTM Crash Prediction
 * @dev Verifies zero-knowledge proofs generated by the ML Sentinel
 * 
 * Integration with Risc Zero zkVM:
 * - Accepts cryptographic receipts from Risc Zero prover
 * - Validates proof seal and journal commitment
 * - Extracts public risk score from journal
 * - Emits events for Aegis Protocol integration
 */
contract AegisRiscZeroVerifier {
    
    /// @notice Risc Zero image ID for the LSTM guest program
    /// @dev This is generated when building the guest code
    bytes32 public constant LSTM_IMAGE_ID = 0x0; // Will be set after building risc0-verifier
    
    /// @notice Mapping to prevent proof replay attacks
    mapping(bytes32 => bool) public usedProofs;
    
    /// @notice Event emitted when a proof is verified
    event ProofVerified(
        bool success,
        uint256 riskScore,      // Risk score (0-10000 basis points, 10000 = 100%)
        bytes32 proofHash,
        uint256 timestamp
    );
    
    /// @notice Event emitted for crash alerts
    event CrashAlert(
        uint256 riskScore,
        uint256 timestamp,
        string severity  // "WARNING" or "CRITICAL"
    );
    
    /// @notice Risk thresholds (in basis points)
    uint256 public constant WARNING_THRESHOLD = 6000;   // 60%
    uint256 public constant CRITICAL_THRESHOLD = 8000;  // 80%
    
    /**
     * @notice Verify a Risc Zero ZK proof for crash prediction
     * @param seal The cryptographic seal (proof)
     * @param imageId The Risc Zero image ID (must match LSTM_IMAGE_ID)
     * @param journal The public journal containing the risk score
     * @return success True if proof is valid
     * @return riskScore The extracted risk score
     */
    function verifyProof(
        bytes calldata seal,
        bytes32 imageId,
        bytes calldata journal
    ) external returns (bool success, uint256 riskScore) {
        
        // 1. Validate image ID matches our LSTM program
        require(imageId == LSTM_IMAGE_ID, "Invalid image ID");
        
        // 2. Check for proof replay
        bytes32 proofHash = keccak256(abi.encodePacked(seal, journal));
        require(!usedProofs[proofHash], "Proof already used");
        
        // 3. For DEMO: Accept seal as valid (in production, call Risc Zero verifier)
        // TODO: Integrate with Risc Zero's Ethereum verifier contract
        // IRiscZeroVerifier(RISC_ZERO_VERIFIER).verify(seal, imageId, journal);
        
        // 4. Extract risk score from journal
        // Journal format: first 32 bytes is the risk score as uint256
        require(journal.length >= 32, "Invalid journal length");
        
        assembly {
            // Load the first 32 bytes of journal (the risk score)
            riskScore := calldataload(journal.offset)
        }
        
        // 5. Validate risk score range
        require(riskScore <= 10000, "Invalid risk score");
        
        // 6. Mark proof as used
        usedProofs[proofHash] = true;
        
        // 7. Emit verification event
        emit ProofVerified(true, riskScore, proofHash, block.timestamp);
        
        // 8. Emit crash alert if threshold exceeded
        if (riskScore >= CRITICAL_THRESHOLD) {
            emit CrashAlert(riskScore, block.timestamp, "CRITICAL");
        } else if (riskScore >= WARNING_THRESHOLD) {
            emit CrashAlert(riskScore, block.timestamp, "WARNING");
        }
        
        success = true;
        return (success, riskScore);
    }
    
    /**
     * @notice Simplified verification for demo (accepts mock proofs)
     * @param proofData The proof data (JSON or binary)
     * @param riskScoreInput The risk score to verify (0-10000 basis points)
     * @return success True if verification succeeds
     */
    function verifyMockProof(
        bytes calldata proofData,
        uint256 riskScoreInput
    ) external returns (bool success) {
        
        // Validate input
        require(riskScoreInput <= 10000, "Invalid risk score");
        require(proofData.length > 0, "Empty proof data");
        
        // Check replay
        bytes32 proofHash = keccak256(proofData);
        require(!usedProofs[proofHash], "Proof already used");
        
        // Mark as used
        usedProofs[proofHash] = true;
        
        // Emit events
        emit ProofVerified(true, riskScoreInput, proofHash, block.timestamp);
        
        if (riskScoreInput >= CRITICAL_THRESHOLD) {
            emit CrashAlert(riskScoreInput, block.timestamp, "CRITICAL");
        } else if (riskScoreInput >= WARNING_THRESHOLD) {
            emit CrashAlert(riskScoreInput, block.timestamp, "WARNING");
        }
        
        return true;
    }
    
    /**
     * @notice Check if a proof has been used
     * @param proofHash The hash of the proof to check
     * @return bool True if proof was already verified
     */
    function isProofUsed(bytes32 proofHash) external view returns (bool) {
        return usedProofs[proofHash];
    }
    
    /**
     * @notice Get contract version
     * @return string Version identifier
     */
    function version() external pure returns (string memory) {
        return "Aegis Risc Zero Verifier v1.0";
    }
    
    /**
     * @notice Decode risk score from journal bytes
     * @param journal The journal bytes from Risc Zero proof
     * @return riskScore The decoded risk score
     */
    function decodeRiskScore(bytes calldata journal) 
        external 
        pure 
        returns (uint256 riskScore) 
    {
        require(journal.length >= 32, "Invalid journal");
        
        assembly {
            riskScore := calldataload(journal.offset)
        }
        
        require(riskScore <= 10000, "Invalid risk score");
        return riskScore;
    }
}
